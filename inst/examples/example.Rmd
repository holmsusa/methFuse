---
title: "Example workflow using FUSE"
author: "Susanna Holmstrom"
date: "2025-05-12"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(fuseR)
```

### Reading in data 
We start by reading in the data, which consist of the tables K0 and K1. Both have CpG loci as rows and samples as columns, and 

- K0 contains the unmethylated counts
- K1 contains the methylated counts

This is a dummy data set consisting of the 100 000 first CpG sites in chromosome 20. 

```{r}
k0 <- read.table(gzfile('k0.tsv.gz'), header = T, row.names = 1)
k1 <- read.table(gzfile('k1.tsv.gz'), header = T, row.names = 1)

head(k0)
```

### Cluster
Next, 'fuse.cluster()' is applied on the count matrices. This performs a hierarchical clustering of closest neighbors, and outputs a clustering tree.

```{r}
tree <- fuse.cluster(as.matrix(k0), as.matrix(k1))
head(tree)
```

The clustering 'tree' contains the following columns:

- 'm1': the label of the first merged point
- 'm2': the label of the second merged point
- 'logl_tot': Change in total log-likelihood for forming this merge
- 'logl_merge': Total cost of the points in this formed cluster
- 'genomic_dist': Distance penalty for this merge

### Number of segments
In order to cut the clustering tree, the optimal number of segments needs to be calculated. Here it is demonstrated using Bayesian Information Criterion (BIC)

```{r}
# To compute BIC, we need the total likelihood of each model. This is the cumulative sum of changes in likelihood.
tree[,3] <- cumsum(tree[,3])

# BIC
bic <- numeric(nrow(tree)) # Initializing empty vector

# Finding number of samples (n), sites (m), and clusters (k). At first, number of clusters is number of sites, in the end all are in one cluster. 
m <- nrow(k0)
n <- ncol(k0)
k <- c(nrow(tree):1)

# Computing BIC for each model (number of clusters)
for( i in 1:nrow(tree)) {
  bic[i] <- n*log(m*n)*k[i] + 2*tree[i, 3]
}
```

We want to chose the model (number of clusters) that minimizes BIC. Let's see what the BIC curve looks like: 

```{r, echo = FALSE}
plot(bic)
points(which.min(bic), min(bic), col = "red", lwd = 2)
```

The red dot in the plot visualizes the model where BIC is minimized. 
```{r}
# Recall that the number of clusters are indexed reversely (k)
optimal_num_of_segments <- length(bic) - (which.min(bic)-1)
optimal_num_of_segments
```

### Cutting the tree
The final step in the workflow is cutting the tree using 'fuse.cutree()'

```{r}
segments <- fuse.cutree(tree, optimal_num_of_segments)
```


### Extra: computing beta-values for the segments and plotting
```{r}
# Preparing normal beta-values for plotting
betas <- data.frame(pos = as.numeric(sub("^chr20.", "", rownames(k0))), 
                    beta = rowSums(k1) / (rowSums(k0 + k1)))
head(betas)
```


```{r}
# Computing beta values of segments
k0_c <- rowsum(k0, group = segments, na.rm = T)
k1_c <- rowsum(k1, group = segments, na.rm = T)

k0_c <- rowSums(k0_c, na.rm = T)
k1_c <- rowSums(k1_c, na.rm = T)

betas_segment <- k1_c / (k0_c + k1_c)
```

```{r}
# Extracting start and end points of segments
location <- cbind(aggregate(betas$pos, by = list(segments), FUN = min), aggregate(betas$pos, by = list(segments), FUN = max)[,2])
names(location) <- c("Segment", "Start", "End")
location$betas <- betas_segment
head(location)
```


Let's visualize a small piece of the result:
```{r, echo = FALSE,  fig.width=12, fig.height=3}
library(ggplot2)

# Only plotting 20 first segments
betas_df <- betas[which(segments %in% c(1:10)), ]
location_df <- location[1:10, ]

# Create the plot
ggplot() +
  geom_segment(
    data = location_df,
    aes(x = Start, xend = End, y = betas, yend = betas, color = betas > 0.5),
    linewidth = 1.2
  ) +
  geom_point(
    data = betas_df,
    aes(x = pos, y = beta),
    color = "black",
    size = 2
  ) +
  scale_color_manual(values = c("FALSE" = "blue", "TRUE" = "red")) +
  labs(x = "Genomic Position", y = "Beta", title = "Segments") +
  theme_minimal()


```
