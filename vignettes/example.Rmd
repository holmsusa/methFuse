---
title: "Example workflow using FUSE"
author: "Susanna Holmstrom"
date: "2025-11-20"
output:  rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Example}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(fuseR)
```

### Reading in data 
We start by reading in the data, which consist of the tables K0 and K1. Both have CpG sites as rows and samples as columns, and 

- K0 contains the unmethylated counts
- K1 contains the methylated counts

This is a dummy data set consisting of manipulated counts of the 100 000 first CpG sites in chromosome 20. 

```{r}
k0_file <- system.file("examples/k0.tsv.gz", package = "fuseR")
k1_file <- system.file("examples/k1.tsv.gz", package = "fuseR")

K0 <- read.table(k0_file, header = TRUE)
K1 <- read.table(k1_file, header = TRUE)


head(K0)
```
### Apply FUSE as a pipeline
The whole FUSE pipeline can be applied using the function 'fuse.segment()'. It performs the following steps: 

1. clustering
2. cutting clustering tree optimally
3. summarizing segments

The function takes as input the count matrices K0 and K1 and the chromosome and position information for each CpG site, and outputs a summary table and a data frame with betas. 
```{r}
segment_result <- fuse.segment(
  as.matrix(K0), 
  as.matrix(K1), 
  chr = sub("\\..*$", "", rownames(K0)), 
  pos = as.numeric(sub("^.*\\.", "", rownames(K0))))

head(segment_result$summary)
```
```{r}
head(segment_result$betas_per_segment)
```

## Apply FUSE through separate steps
If the intermediate outputs of the method are relevant, then the pipeline can also be applied by calling each of the functions 'fuse.cluster()', 'number.of.clusters()', 'fuse.cut.tree()', and 'fuse.summary()' separately. 

### 1. Cluster
In the first step, 'fuse.cluster()' is applied on the count matrices. This performs a hierarchical clustering of closest neighbors, and outputs a clustering tree.

```{r}
tree <- fuse.cluster(as.matrix(K0), as.matrix(K1))
head(tree)
```

The clustering 'tree' contains the following columns:

- 'm1': the label of the first merged point
- 'm2': the label of the second merged point
- 'logl_tot': Change in total log-likelihood for forming this merge
- 'logl_merge': Total cost of the points in this formed cluster
- 'genomic_dist': Distance penalty for this merge

### 2. Cutting the tree
In order to cut the clustering tree, the optimal number of segments needs to be calculated. For this we have the function 'number.of.clusters()', which performs model selection by minimizing either the Bayesian Information Criterion (BIC, default), or the Akaike Information Criterion (AIC).

```{r}
# Need the total likelihood per model, which is sum of likelihood changes
tree[,3] <- cumsum(tree[,3])

optimal_num_of_segments <- number.of.clusters(tree, ncol(K0), 'BIC')
optimal_num_of_segments
```

The tree can then be cut using 'fuse.cut.tree()'

```{r}
segments <- fuse.cut.tree(tree, optimal_num_of_segments)
head(segments, 100)
```


### 3. Summarizing segments
The segments can be summarized in a table with the function 'fuse.summary()'.
```{r}
result <- fuse.summary(as.matrix(K0), 
                       as.matrix(K1), 
                       chr = sub("\\..*$", "", rownames(K0)), 
                       pos = as.numeric(sub("^.*\\.", "", rownames(K0))), 
                       segments)

head(result$summary)
```
```{r}
head(result$betas_per_segment)
```

### Verification
The outputs are identical.
```{r}
identical(segment_result$summary, result$summary)
```

```{r}
identical(segment_result$betas_per_segment, result$betas_per_segment)
```

## Plotting
Let's visualize a small piece of the result:
```{r, echo = FALSE,  fig.width=12, fig.height=3}
library(ggplot2)

# Only plotting 20 first segments
raw_betas <- K1[which(segments %in% c(1:10)), ]  / (K1[which(segments %in% c(1:10)), ]  + K0[which(segments %in% c(1:10)), ])

# Division by 0 will be full noise, beta = 0.5
raw_betas[] <- lapply(raw_betas, function(x) {
  x[is.infinite(x)] <- 0.5
  x
})

# Average over samples for plotting
betas_df <- data.frame(beta = rowMeans(raw_betas), pos =  as.numeric(sub("^.*\\.", "", rownames(raw_betas))))

# Create the plot
ggplot() +
  geom_segment(
    data = result$summary[1:10, ],
    aes(x = Start, xend = End, y = Beta, yend = Beta, color = Beta > 0.5),
    linewidth = 1.2
  ) +
  geom_point(
    data = betas_df,
    aes(x = pos, y = beta),
    color = "black",
    size = 2
  ) +
  scale_color_manual(values = c("FALSE" = "blue", "TRUE" = "red")) +
  labs(x = "Genomic Position", y = "Beta", title = "Segments") +
  theme_minimal()


```
